"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JwtHandler = void 0;
const jwt_decode_1 = __importDefault(require("jwt-decode"));
const rfc4648_1 = require("rfc4648");
const plugin_error_1 = require("../error/plugin-error");
/**
 * Service class providing functionality to handle and verify JSON Web Tokens.
 */
class JwtHandler {
    /**
     * Decodes a Base64Url encoded JSON Web Token header.
     *
     * @param token the JWT token
     * @returns the decoded JSON header parameters or `null` if it is not a JWT token
     */
    decodeJwtHeader(token) {
        return this.isJwt(token) ? jwt_decode_1.default(token, { header: true }) : null;
    }
    /**
     * Decodes a Base64Url encoded JSON Web Token.
     *
     * @param token the JWT token
     * @returns the decoded JSON object or `null` if it is not a JWT token
     */
    decodeJwtClaims(token) {
        return this.isJwt(token) ? jwt_decode_1.default(token) : null;
    }
    /**
     * Verifies the signature of the given JSON Web Token against a set of keys.
     * Only one of the keys needs to match in order to resolve the resulting
     * promise.
     *
     * @param token the JWT token
     * @param key the set of keys to check the token against
     * @returns an empty promise that resolves if the token is valid
     */
    verifyJwt(token, ...keys) {
        const encoder = new window.TextEncoder();
        const [header, payload, signature] = token.split('.');
        const data = encoder.encode(`${header}.${payload}`);
        const sign = rfc4648_1.base64url.parse(signature, { loose: true });
        if (!window.crypto || !window.crypto.subtle) {
            Promise.reject(new plugin_error_1.PluginError(plugin_error_1.PluginErrorCode.CryptoNotFound, 'Insecure plug-in communication', true));
        }
        return Promise.any(keys.map(key => window.crypto.subtle
            .verify(key.algorithm, key, sign, data)
            .then(valid => (valid ? Promise.resolve() : Promise.reject())))).catch(() => Promise.reject(new plugin_error_1.PluginError(plugin_error_1.PluginErrorCode.InvalidTokenSignature, 'Invalid plug-in token')));
    }
    /**
     * Validates the given decoded JWT token. Checks if the given claims align
     * with the validation claims. Furthermore the token's `nbf` and `exp` claims
     * are checked if they are defined in the token. A small leeway, usually no
     * more than a few minutes, may be used to account for clock skew.
     *
     * @param claims the decoded JWT token
     * @param validation the reference claims to check
     * @param leeway a small leeway to account for clock skew
     * @returns an empty promise that resolves if the token is valid
     */
    validateJwt(claims, validation, leeway = 60000) {
        const validationClaims = ['iss', 'sub', 'aud', 'jti'];
        for (const claim of validationClaims) {
            if (validation[claim] && validation[claim] !== claims[claim]) {
                return Promise.reject(new plugin_error_1.PluginError(plugin_error_1.PluginErrorCode.InvalidTokenClaim, 'Invalid plug-in token'));
            }
        }
        const now = Date.now();
        if (claims.exp && claims.exp >= now + leeway) {
            return Promise.reject(new plugin_error_1.PluginError(plugin_error_1.PluginErrorCode.InvalidTokenExp, 'Invalid plug-in token'));
        }
        else if (claims.nbf && claims.nbf < now - leeway) {
            return Promise.reject(new plugin_error_1.PluginError(plugin_error_1.PluginErrorCode.InvalidTokenNbf, 'Invalid plug-in token'));
        }
        return Promise.resolve();
    }
    isJwt(token) {
        return typeof token === 'string' && token.match(/^[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*$/) !== null;
    }
}
exports.JwtHandler = JwtHandler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiand0LWhhbmRsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvbGliL2p3dC9qd3QtaGFuZGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSw0REFBb0M7QUFDcEMscUNBQW9DO0FBRXBDLHdEQUFxRTtBQUtyRTs7R0FFRztBQUNILE1BQWEsVUFBVTtJQUNyQjs7Ozs7T0FLRztJQUNILGVBQWUsQ0FBQyxLQUFhO1FBQzNCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsb0JBQVUsQ0FBWSxLQUFLLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ25GLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGVBQWUsQ0FBQyxLQUFhO1FBQzNCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsb0JBQVUsQ0FBWSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ2pFLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILFNBQVMsQ0FBQyxLQUFhLEVBQUUsR0FBRyxJQUFpQjtRQUMzQyxNQUFNLE9BQU8sR0FBRyxJQUFJLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN6QyxNQUFNLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RELE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxNQUFNLElBQUksT0FBTyxFQUFFLENBQUMsQ0FBQztRQUNwRCxNQUFNLElBQUksR0FBRyxtQkFBUyxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUV6RCxJQUFJLENBQUMsTUFBTSxD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